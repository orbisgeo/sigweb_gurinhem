<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mapa Interativo com Visualiza√ß√£o de Atributos (OpenLayers)</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/css/ol.css" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/build/ol.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/jsts@2.0.0/dist/jsts.min.js"></script>

    <style>
        
        :root {
            --bg-body: #f9fafb;
            --bg-white: #ffffff;
            --text-color: #111827;
            --primary: #2563eb;
            --dark: #111827;
            --dark-hover: #1f2937;
            --border-radius: 10px;
            --box-shadow: 0 6px 20px rgba(0, 0, 0, .12);
            --font-main: 'Rubik', sans-serif; /* Not directly used, but kept for consistency */
            --font-size-sm: 13px;
            --font-size-md: 14px;
        }

        html, body {
            height: 100%;
            width: 100%; /* Adicionado para garantir 100% de largura */
            margin: 0;
            padding: 0; /* Adicionado para remover padding padr√£o */
            background: var(--bg-body);
            overflow: hidden; /* Adicionado para evitar barras de rolagem */
        }

        #map {
            height: 100%;
            width: 100%;
            min-height: 200px; /* Garante uma altura m√≠nima para o mapa */
            position: relative; /* Importante para posicionamento de controles */
        }

        /* Classes para o MODO IMPRESS√ÉO (visualiza√ß√£o na tela) */
        body.print-mode-active {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Garante que n√£o apare√ßam barras de rolagem */
            background-color: #e0e0e0; /* Fundo cinza claro para simular a √°rea fora do A4 */
            /* Usar flexbox para centralizar o mapa A4 na tela */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Garante que o body ocupe a altura total da viewport */
            width: 100vw; /* Garante que o body ocupe a largura total da viewport */
        }

        #map.print-mode-active {
            /* Tamanho A4 retrato em pixels para visualiza√ß√£o em tela (96 DPI) */
            /* A4: 210mm x 297mm. Aprox. 794px x 1123px @ 96DPI */
            width: 794px !important;
            height: 1123px !important;
            position: relative !important; /* Mudei para relative, pois o flexbox do body centraliza */
            top: auto !important; /* Reseta as propriedades de posi√ß√£o absoluta */
            left: auto !important;
            transform: none !important; /* Reseta a transforma√ß√£o de centraliza√ß√£o */
            border: 1px solid #333; /* Borda para demarcar o A4 */
            box-shadow: var(--box-shadow);
            margin: 0 !important; /* Garante que o mapa n√£o tenha margem pr√≥pria */
        }
        /* FIM das classes para o MODO IMPRESS√ÉO */


        .form-container {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 1000;
            width: 260px;
            background: var(--bg-white);
            padding: 16px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        /* Oculta os controles padr√£o quando no modo de impress√£o (via JS) */
        .form-container.hidden-for-print, 
        .custom-layer-control.hidden-for-print,
        .search-container.hidden-for-print {
            display: none !important;
        }
        /* Os controles padr√µes do OpenLayers ser√£o escondidos via classes adicionadas a eles dinamicamente */

        .form-container h4 {
            margin: 0 0 10px 0;
        }

        .form-container input, .form-container button, .form-container select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            font-size: var(--font-size-md);
            border: 1px solid #cbd5e1;
            border-radius: var(--border-radius);
            box-sizing: border-box; /* Garante que padding e border sejam inclu√≠dos na largura */
        }

        .form-container button {
            font-weight: bold;
            border: none;
            cursor: pointer;
            background: var(--dark);
            color: #fff;
        }

        .form-container button:hover {
            background: var(--dark-hover);
        }

        .btn-apagar {
            background: #dc2626 !important;
        }

        .btn-ordenar {
            background: var(--primary);
        }

        /* Estilo para a tooltip de ordem (similar ao Leaflet) */
        .ol-tooltip {
            position: relative;
            background: rgba(255, 255, 255, .85);
            padding: 2px 5px;
            border-radius: 4px;
            white-space: nowrap;
            font-weight: 600;
            color: var(--text-color);
            border: 1px solid #ccc;
            font-size: 11px;
        }

        /* Estilo para o controle de camadas customizado */
        .custom-layer-control {
            position: absolute;
            top: 400px; /* Ajuste conforme necess√°rio */
            left: 16px; 
            z-index: 1000;
            background: var(--bg-white);
            padding: 10px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            font-size: var(--font-size-sm);
        }
        .custom-layer-control label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
        }

        /* Basic popup styling */
        .ol-popup {
            background-color: white;
            border: 1px solid #cccccc;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border-radius: 5px;
            min-width: 200px;
        }
        /* Estilos para o popup de exporta√ß√£o */
        .swal2-select {
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .swal2-radio label {
            display: block;
            margin-bottom: 5px;
        }
        /* Style for the attribute table in the popup */
        .table-attributes {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        .table-attributes td {
            padding: 5px 0;
            vertical-align: top;
        }
        .table-attributes strong {
            display: block;
            margin-bottom: 3px;
        }
        /* ATEN√á√ÉO: ESTE ESTILO √â AGORA PARA VISUALIZA√á√ÉO, N√ÉO EDI√á√ÉO */
        .table-attributes .attribute-value { 
            padding: 5px;
            border: 1px solid #eee; /* Borda mais suave para visualiza√ß√£o */
            border-radius: 3px;
            background-color: #f9f9f9; /* Fundo claro para o valor */
            display: block; /* Garante que ocupe a largura completa */
            word-wrap: break-word; /* Quebra texto longo */
        }
        /* Styles for field management popup */
        .field-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        .field-list li {
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
        }
        .field-list li:last-child {
            border-bottom: none;
        }
        .field-list li button {
            background-color: #dc2626;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: var(--font-size-sm);
            margin-left: 10px;
            width: auto; /* Override default button width */
            margin-bottom: 0; /* Override default button margin */
        }
        .field-list li button:hover {
            background-color: #ef4444;
        }
        .add-field-section {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        /* Measurement tool styles */
        .ol-tooltip-measure {
            background: rgba(255, 255, 255, 0.85);
            color: black;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 14px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            pointer-events: none; /* Prevents tooltip from blocking clicks */
        }
        .ol-tooltip-static {
            background-color: #ffcc33;
            color: black;
            border: 1px solid white;
        }
        .ol-tooltip-measure:before,
        .ol-tooltip-static:before {
            border-top: 6px solid rgba(255, 255, 255, 0.85);
            border-right: 6px solid transparent;
            border-left: 6px solid transparent;
            content: "";
            position: absolute;
            bottom: -6px;
            margin-left: -7px;
            left: 50%;
        }
        .ol-tooltip-static:before {
            border-top-color: #ffcc33;
        }

        /* Print Mode UI */
        .print-mode-controls {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001; /* Acima do mapa e outros controles */
            background: var(--bg-white);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: none; /* Hidden by default */
            white-space: nowrap; /* Impede que os bot√µes quebrem linha */
        }
        .print-mode-controls button {
            margin: 0 5px;
            width: auto; /* Desfaz o 100% de largura */
            display: inline-block; /* Alinha os bot√µes na mesma linha */
            padding: 8px 15px;
            font-size: var(--font-size-md);
        }

        /* North Arrow for Print (posicionamento dentro do mapa A4) */
        #northArrowPrint {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 3em; /* Aumenta o tamanho da seta */
            color: #333; /* Cor escura para contrastar */
            z-index: 1000;
            display: none; /* Hidden by default, shown in print mode or actual print */
            font-weight: bold; /* Deixa o "N" mais vis√≠vel */
            text-shadow: 0 0 2px rgba(255,255,255,0.7); /* Sombra para ajudar no contraste */
        }

        /* OpenLayers ScaleLine control - default styles from ol.css */
        /* Make sure it's hidden by default and only shown when explicitly made visible */
        .ol-scale-line {
            display: none; /* Hidden by default in normal mode */
        }

        /* Make OL ScaleLine visible and position it for print mode (on-screen A4 simulation) */
        .ol-scale-line.visible-for-print {
            display: block !important; /* Override default hidden state */
            position: absolute;
            bottom: 20px;
            left: 20px; /* Posiciona no canto inferior esquerdo do mapa A4 */
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        /* CSS para a impress√£o real (quando window.print() √© chamado) */
        @media print {
            /* Remove cabe√ßalhos e rodap√©s do navegador e define o tamanho da p√°gina */
            @page {
                size: A4 portrait; /* Define o tamanho da p√°gina e orienta√ß√£o */
                margin: 0 !important; /* Remove as margens padr√£o do navegador */
            }

            html, body {
                height: 100% !important;
                width: 100% !important;
                margin: 0 !important; /* For√ßa zero margem */
                padding: 0 !important; /* For√ßa zero padding */
                overflow: hidden !important; /* Remove barras de rolagem na impress√£o */
            }
            #map {
                width: 210mm !important; /* A4 Portrait Width */
                height: 297mm !important; /* A4 Portrait Height */
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                transform: none !important; /* Remove a centraliza√ß√£o em tela */
                border: none !important; /* Remove borda da visualiza√ß√£o */
                box-shadow: none !important; /* Remove sombra da visualiza√ß√£o */
                margin: 0 !important; /* Garante que o mapa n√£o tenha margem pr√≥pria na impress√£o */
            }
            /* Oculta TUDO que n√£o √© mapa e elementos de impress√£o na sa√≠da f√≠sica */
            .form-container, .custom-layer-control, .print-mode-controls,
            .ol-zoom, .ol-rotate, .ol-attribution, /* Outros controles OL que podem aparecer */
            .ol-tooltip, .ol-tooltip-help, .ol-tooltip-measure, .search-container {
                display: none !important;
            }
            /* Garante que seta do norte e escala gr√°fica sejam vis√≠veis na impress√£o */
            #northArrowPrint, .ol-scale-line {
                display: block !important;
            }
            /* Ajusta a posi√ß√£o final da escala gr√°fica para a impress√£o se for diferente da visualiza√ß√£o */
            .ol-scale-line {
                bottom: 20px !important;
                left: 20px !important;
                right: auto !important; /* Garante que n√£o haja conflito com 'right' */
            }
            #northArrowPrint {
                top: 20px !important;
                right: 20px !important;
                left: auto !important; /* Garante que n√£o haja conflito com 'left' */
            }
        }

        /* Search container specific styles */
        .search-container {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 1000;
            width: 260px;
            background: var(--bg-white);
            padding: 16px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .search-container h4 {
            margin: 0 0 10px 0;
        }

        .search-container label {
            font-size: var(--font-size-md);
            margin-bottom: 5px;
            display: block; /* Para que a label ocupe sua pr√≥pria linha */
        }

        .search-container select,
        .search-container input[type="text"],
        .search-container button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            font-size: var(--font-size-md);
            border: 1px solid #cbd5e1;
            border-radius: var(--border-radius);
            box-sizing: border-box;
        }

        .search-container button {
            background: var(--primary);
            color: #fff;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }

        .search-container button:hover {
            background: var(--dark-hover);
        }

        #sugestoes {
            border: 1px solid #ddd;
            max-height: 150px;
            overflow-y: auto;
            background-color: white;
            position: absolute;
            width: calc(100% - 32px); /* Adjust for padding of the parent container */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1001; /* Above other elements */
            display: none; /* Hidden by default */
        }

        .sugestao-item {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .sugestao-item:hover {
            background-color: #f0f0f0;
        }

        .sugestao-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div class="form-container" id="mainFormContainer">
        <h4>Ferramentas do Mapa</h4>
        <button id="btnMeasureDistance" onclick="mapFunctions.toggleMeasureDistance()">üìè Medir Dist√¢ncia</button>
        <button id="btnMeasureArea" onclick="mapFunctions.toggleMeasureArea()">üìê Medir √Årea</button>
        <button id="btnClearMeasure" onclick="mapFunctions.clearMeasurements()">üóëÔ∏è Limpar Medi√ß√µes</button>
        <hr />
        <button id="btnExportLayers" onclick="mapFunctions.mostrarOpcoesExportacao()">üì§ Exportar Camada (KML)</button>
        <hr />
        <button id="btnPrintMap" onclick="mapFunctions.activatePrintMode()">üñ®Ô∏è Imprimir Mapa</button>
    </div>

    <div id="customLayerControl" class="custom-layer-control">
        <h4>Camadas</h4>
    </div>

    <div id="searchContainer" class="search-container">
        <h4>Buscar Fei√ß√£o</h4>
        <label for="camadaSelect">Camada:</label>
        <select id="camadaSelect"></select>

        <label for="campoSelect">Campo:</label>
        <select id="campoSelect"></select>

        <label for="valorBusca">Valor:</label>
        <input type="text" id="valorBusca" placeholder="Digite para buscar..." autocomplete="off">
        <div id="sugestoes"></div>

        <button onclick="mapFunctions.buscarFeicao()">üîç Buscar</button>
        <button onclick="mapFunctions.clearSearchHighlight()" style="background: #ef4444;">‚ùå Limpar Busca</button>
    </div>

    <div id="printModeControls" class="print-mode-controls">
        <p style="margin: 0 0 10px 0; font-weight: bold;">Ajuste o mapa para a impress√£o:</p>
        <button onclick="mapFunctions.triggerPrint()">üñ®Ô∏è Imprimir Agora</button>
        <button onclick="mapFunctions.deactivatePrintMode()" style="background: #ef4444;">‚úñÔ∏è Cancelar</button>
    </div>

    <div id="northArrowPrint">‚Üë N</div>
    <script>
        /* ================= Firebase ================= */
        const firebaseConfig = {
            apiKey: "AIzaSyDxxxxxxx", // Substitua PELA SUA CHAVE REAL DA API DO FIREBASE
            authDomain: "ruas-gurinhem.firebaseapp.com",
            projectId: "ruas-gurinhem"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // ====================================================================
        // Habilitar Persist√™ncia Offline do Firestore.
        // Isso deve ser feito ANTES de qualquer outra chamada ao Firestore.
        // ====================================================================
        db.enablePersistence()
            .then(() => {
                console.log("Persist√™ncia Offline do Firestore habilitada com sucesso!");
                initializeMapAndLayers(); // Chamada √† nova fun√ß√£o de inicializa√ß√£o
            })
            .catch((err) => {
                if (err.code === 'failed-precondition') {
                    console.warn("M√∫ltiplas abas abertas, persist√™ncia offline n√£o pode ser habilitada. Funcionar√° online.");
                } else if (err.code === 'unimplemented') {
                    console.warn("O navegador atual n√£o suporta todos os recursos para persist√™ncia offline.");
                } else {
                    console.error("Erro ao habilitar persist√™ncia offline:", err);
                }
                initializeMapAndLayers(); // Ainda assim, inicialize o mapa para funcionar online
            });

        // ====================================================================
        // EXPOSI√á√ÉO DE FUN√á√ïES GLOBAIS PARA O HTML
        // Estas fun√ß√µes s√£o chamadas diretamente pelos 'onclick' no HTML
        // e precisam estar no escopo global (window). Elas apenas chamam
        // os m√©todos correspondentes dentro do objeto mapFunctions, que √©
        // definido em 'initializeMapAndLayers'.
        // ====================================================================
        let mapFunctions = {}; // Declarado aqui para ser globalmente acess√≠vel

        // Atribui√ß√µes diretas para chamadas onclick no HTML
        window.toggleMeasureDistance = () => mapFunctions.toggleMeasureDistance();
        window.toggleMeasureArea = () => mapFunctions.toggleMeasureArea();
        window.clearMeasurements = () => mapFunctions.clearMeasurements();
        window.activatePrintMode = () => mapFunctions.activatePrintMode();
        window.triggerPrint = () => mapFunctions.triggerPrint();
        window.deactivatePrintMode = () => mapFunctions.deactivatePrintMode();
        window.mostrarOpcoesExportacao = () => mapFunctions.mostrarOpcoesExportacao();
        // REMOVIDO: window.salvarPopupEdicao = (camadaKey, featureId, updatedProps) => mapFunctions.salvarPopupEdicao(camadaKey, featureId, updatedProps);
        window.buscarFeicao = () => mapFunctions.buscarFeicao(); // Torna a fun√ß√£o de busca acess√≠vel globalmente
        window.clearSearchHighlight = () => mapFunctions.clearSearchHighlight(); // Torna a fun√ß√£o de limpar destaque acess√≠vel globalmente


        // Fun√ß√£o principal para inicializar o mapa e carregar as camadas
        function initializeMapAndLayers() {
            /* ================= Vari√°veis e Configura√ß√µes Globais do Mapa ================= */
            const osmLayer = new ol.layer.Tile({
                title: "üó∫Ô∏è OpenStreetMap",
                type: 'base',
                source: new ol.source.OSM(),
                visible: true
            });

            const sateliteLayer = new ol.layer.Tile({
                title: "üõ∞Ô∏è Sat√©lite MapTiler",
                type: 'base',
                source: new ol.source.XYZ({
                    url: 'https://api.maptiler.com/maps/hybrid/{z}/{x}/{y}.jpg?key=o9sqJVKN8wxu8WXujuRl', // Replace with your MapTiler API Key
                    tileSize: 512,  
                }),
                visible: false
            });

            const emptyLayer = new ol.layer.Tile({
                title: "üö´ Sem Base",
                type: 'base',
                source: new ol.source.TileDebug({
                    projection: 'EPSG:3857',
                    
                }),
                visible: false
            });

            // Instancia o controle de escala para poder manipul√°-lo
            const scaleLineControl = new ol.control.ScaleLine({
                units: 'metric', // Medidas m√©tricas (m, km)
                bar: true, // Renderiza como barra
                steps: 4, // N√∫mero de divis√µes na barra
                text: true, // Mostra o texto da escala
                minWidth: 140 // Largura m√≠nima da barra para exibir texto
            });

            const map = new ol.Map({
                target: 'map',
                layers: [
                    osmLayer,
                    sateliteLayer,
                    emptyLayer,
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([-35.42, -7.12]), // Guarabira, PB, Brazil
                    zoom: 16,
                    maxZoom: 28,  
                    minZoom: 1  
                }),
                controls: ol.control.defaults().extend([
                    scaleLineControl, // Adiciona o ScaleLine ao mapa
                    new ol.control.ZoomSlider()
                ])
            });

            // Get references to core UI elements for show/hide logic
            const mainFormContainer = document.getElementById('mainFormContainer');
            const customLayerControl = document.getElementById('customLayerControl');
            const searchContainer = document.getElementById('searchContainer'); // Novo container de busca
            const printModeControls = document.getElementById('printModeControls');
            const northArrowPrint = document.getElementById('northArrowPrint');

            // Identifica os controles padr√£o do OpenLayers para esconder no modo impress√£o
            const olControlsToHide = [
                document.querySelector('.ol-zoom'),
                document.querySelector('.ol-rotate'),  
                document.querySelector('.ol-attribution'),  
            ].filter(Boolean);  

            map.getLayers().forEach(layer => {
                if (layer.get('type') === 'base') {
                    const label = document.createElement('label');
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = 'baseLayer';
                    radio.value = layer.get('title');
                    radio.checked = layer.getVisible();
                    radio.onchange = () => {
                        map.getLayers().forEach(l => {
                            if (l.get('type') === 'base') {
                                l.setVisible(l === layer);
                            }
                        });
                    };
                    label.appendChild(radio);
                    label.appendChild(document.createTextNode(layer.get('title')));
                    customLayerControl.appendChild(label);
                }
            });

            /* ================= Camadas GeoData (OpenLayers) ================= */
            const camadas = {
                zona_de_expansao:  { nome: "Zona de Expansao",  cor: "#DAA520", layer: null, source: null },
                ZONA_URBANA:       { nome: "Zona Urbana",       cor: "#8FBC8F", layer: null, source: null },
                BAIRROS_GR:        { nome: "Bairros",           cor: "#DDA0DD", layer: null, source: null },
                QUADRAS_GR:        { nome: "Quadras",           cor: "#BDB76B", layer: null, source: null },
                lotes_rib:         { nome: "Lotes Ribeir√£o",    cor: "#D2B48C", layer: null, source: null },
                rodovia:           { nome: "Rodovias",          cor: "#FF4500", layer: null, source: null },
                predios_publicos_PMG: { nome: "Predios Publicos", tipo: "ponto", cor: "#000080", layer: null, source: null },
                corpos_hidricos_gr: { nome: "Corpos H√≠dricos",  cor: "#4682B4", layer: null, source: null },
                ruas_nomeadas:      { nome: "Ruas",             cor: "#A52A2A", layer: null, source: null }
            };

            let selectedFeature = null;
            let selectedFeatureId = null;

            const featureIndex = {}; // Armazena {feature: featureObject, camada: layerKey, props: originalProps}

            let drawInteraction;  
            let modifyInteraction;  

            // Vari√°veis de Medi√ß√£o
            let measureDraw;
            let measureSource;
            let measureLayer;
            let helpTooltipElement;  
            let helpTooltip;    
            let measureTooltipElement;  
            let measureTooltip;    
            let continuePolygon;
            let continueLine;

            const jstsOlParser = new jsts.io.OL3Parser();  

            // --- Estilos OpenLayers ---
            function getPolygonStyle(color, weight = 1, opacity = 0.5, text = '') {
                let fillColorArray = ol.color.fromString(String(color) || getRandomColor());
                fillColorArray[3] = opacity;  

                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#000000',
                        width: weight  
                    }),
                    fill: new ol.style.Fill({
                        color: fillColorArray
                    }),
                    text: text ? getTextStyle(text) : undefined  
                });
            }

            function getPointStyle(color, radius = 6, text = '') {
                return new ol.style.Style({
                    image: new ol.style.Circle({
                        fill: new ol.style.Fill({ color: String(color) }),  
                        stroke: new ol.style.Stroke({ color: '#fff', width: 1 }),
                        radius: radius
                    }),
                    text: text ? getTextStyle(text) : undefined  
                });
            }

            function getTextStyle(text) {
                return new ol.style.Text({
                    font: 'bold 11px "Open Sans", "Arial Unicode MS", "sans-serif"',
                    fill: new ol.style.Fill({ color: '#000' }),
                    stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                    text: text
                });
            }

            async function carregarCamada(key) {
                const cfg = camadas[key];
                const ref = db.collection("GeoData").doc(key).collection("features");
                const snap = await ref.get();

                const features = [];
                snap.forEach(doc => {
                    const dados = doc.data();
                    const geojson = JSON.parse(dados.geometry);
                    const props = dados.properties || {};
                    const docId = doc.id;

                    const format = new ol.format.GeoJSON();
                    const feature = format.readFeature(geojson, {
                        dataProjection: 'EPSG:4326',  
                        featureProjection: 'EPSG:3857'  
                    });
                    feature.setId(docId);
                    feature.setProperties(props);

                    // Inicializa featureIndex com uma c√≥pia limpa das propriedades
                    const cleanProps = {};
                    for(const pKey in props) {
                        if (pKey !== 'geometry' && pKey !== 'id' && pKey !== 'bbox' && pKey !== 'style') {
                            cleanProps[pKey] = props[pKey];
                        }
                    }
                    featureIndex[docId] = { feature: feature, camada: key, props: cleanProps };

                    if (props.inscricao_imobiliaria) {
                        feature.setStyle((feature, resolution) => {
                            const styleFunction = cfg.tipo === "ponto" ? getPointStyle : getPolygonStyle;
                            return styleFunction(cfg.cor, undefined, undefined, props.inscricao_imobiliaria);
                        });
                    } else if (props.ordem !== undefined && props.ordem !== null) {
                        feature.setStyle((feature, resolution) => {
                            const styleFunction = cfg.tipo === "ponto" ? getPointStyle : getPolygonStyle;
                            return styleFunction(cfg.cor, undefined, undefined, String(props.ordem));
                        });
                    } else {
                        feature.setStyle((feature, resolution) => {
                            const styleFunction = cfg.tipo === "ponto" ? getPointStyle : getPolygonStyle;
                            return styleFunction(cfg.cor);
                        });
                    }
                    
                    features.push(feature);
                });

                cfg.source = new ol.source.Vector({ features: features });

                if (cfg.tipo === "ponto") {
                    cfg.layer = new ol.layer.Vector({
                        title: cfg.nome,
                        source: cfg.source,
                        renderBuffer: 200,  
                        style: (feature) => {
                            const styleFunction = getPointStyle;
                            if (feature.get('inscricao_imobiliaria')) {
                                return styleFunction(cfg.cor, undefined, feature.get('inscricao_imobiliaria'));
                            } else if (feature.get('ordem') !== undefined && feature.get('ordem') !== null) {
                                return styleFunction(cfg.cor, undefined, String(feature.get('ordem')));
                            }
                            return styleFunction(cfg.cor);
                        }
                    });
                } else {
                    cfg.layer = new ol.layer.Vector({
                        title: cfg.nome,
                        source: cfg.source,
                        renderBuffer: 200,  
                        style: (feature) => {
                            const styleFunction = getPolygonStyle;
                            if (feature.get('inscricao_imobiliaria')) {
                                return styleFunction(cfg.cor, undefined, undefined, feature.get('inscricao_imobiliaria'));
                            } else if (feature.get('ordem') !== undefined && feature.get('ordem') !== null) {
                                return styleFunction(cfg.cor, undefined, undefined, String(feature.get('ordem')));
                            }
                            return styleFunction(cfg.cor);
                        }
                    });
                }

                map.addLayer(cfg.layer);

                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;  
                checkbox.onchange = () => cfg.layer.setVisible(checkbox.checked);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(cfg.nome));
                customLayerControl.appendChild(label);
            }

            // Carrega todas as camadas ao inicializar o mapa
            Object.keys(camadas).forEach(carregarCamada);

            const select = new ol.interaction.Select({
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#f00',
                        width: 3
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(255,0,0,0.2)'
                    }),
                    image: new ol.style.Circle({
                        radius: 8,
                        fill: new ol.style.Fill({ color: '#f00' }),
                        stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                    })
                }),
                layers: (layer) => {
                    return Object.values(camadas).some(cfg => cfg.layer === layer);
                }
            });
            map.addInteraction(select);

            select.on('select', (event) => {
                if (event.selected.length > 0) {
                    selectedFeature = event.selected[0];
                    selectedFeatureId = selectedFeature.getId();
                } else {
                    selectedFeature = null;
                    selectedFeatureId = null;
                }
            });

            const popupElement = document.createElement('div');
            popupElement.className = 'ol-popup';
            popupElement.style.display = 'none'; // Inicialmente oculto
            document.body.appendChild(popupElement);

            const popupOverlay = new ol.Overlay({
                element: popupElement,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            map.addOverlay(popupOverlay);

            map.on('click', async (event) => {
                const feature = map.forEachFeatureAtPixel(event.pixel, (feature, layer) => {
                    // Evita abrir popup ao clicar na fei√ß√£o destacada pela busca
                    if (feature === currentSearchHighlightFeature) {
                        return null;  
                    }
                    return feature;
                });

                if (feature) {
                    const featureId = feature.getId();
                    const camadaKey = Object.keys(camadas).find(key => camadas[key].layer.getSource().getFeatureById(featureId));

                    if (!camadaKey) {
                        console.warn("Camada da fei√ß√£o selecionada n√£o encontrada para popup de visualiza√ß√£o.");
                        return;
                    }
                    
                    // Usa propriedades de featureIndex para gera√ß√£o consistente do popup
                    const featureProps = featureIndex[featureId]?.props || {};

                    Swal.fire({
                        title: `Atributos: ${camadas[camadaKey]?.nome || 'Desconhecida'}`,
                        html: mapFunctions.gerarPopupVisualizacao(featureProps), // CHAMADA AGORA PARA VISUALIZA√á√ÉO
                        focusConfirm: false,
                        showCancelButton: false, // REMOVE O BOT√ÉO DE CANCELAR
                        confirmButtonText: 'Fechar', // MUDA O TEXTO DO BOT√ÉO DE CONFIRMA√á√ÉO
                        position: 'top-end', // Posiciona o popup no canto superior direito
                        width: '400px',      // Ajusta largura
                        backdrop: false,     // Permite intera√ß√£o com o mapa por tr√°s
                    });

                }
            });

            /* ================= Defini√ß√£o das Fun√ß√µes do Mapa em mapFunctions ================= */

            // REMOVIDA: mapFunctions.salvarAtributos = function() { ... }

            mapFunctions.criarModo = async function() {
                // Esta fun√ß√£o pode ser removida se a cria√ß√£o de novos pontos n√£o for permitida.
                // Mantida por enquanto, mas considere se faz sentido em um mapa "somente leitura" de atributos.
                if (drawInteraction) map.removeInteraction(drawInteraction);
                if (modifyInteraction) map.removeInteraction(modifyInteraction);

                const { value: formValues } = await Swal.fire({
                    title: 'Novo Pr√©dio',
                    html:
                        '<input id="swal-nome" class="swal2-input" placeholder="Nome do pr√©dio">' +
                        '<input id="swal-tipo" class="swal2-input" placeholder="Tipo">',
                    focusConfirm: false,
                    showCancelButton: true,
                    position: 'top-end', // Posiciona o popup no canto superior direito
                    width: '400px',      // Ajusta largura
                    backdrop: false,     // Permite intera√ß√£o com o mapa por tr√°s
                    preConfirm: () => {
                        const nome = document.getElementById('swal-nome').value;
                        const tipo = document.getElementById('swal-tipo').value;
                        if (!nome || !tipo) {
                            Swal.showValidationMessage('Por favor, preencha todos os campos');
                            return false;
                        }
                        return { nome: nome, tipo: tipo };
                    }
                });

                if (formValues) {
                    const drawSource = new ol.source.Vector();
                    const drawLayer = new ol.layer.Vector({
                        source: drawSource,
                        style: getPointStyle('#0066CC')
                    });
                    map.addLayer(drawLayer);

                    drawInteraction = new ol.interaction.Draw({
                        source: drawSource,
                        type: 'Point',
                    });
                    map.addInteraction(drawInteraction);

                    Swal.mixin({
                        toast: true,
                        position: 'top-end',
                        showConfirmButton: false,
                        timer: 3000,
                        timerProgressBar: true,
                    }).fire({
                        icon: 'info',
                        title: 'Clique no mapa para adicionar o novo ponto.'
                    });
                    document.body.style.cursor = "crosshair";

                    drawInteraction.once('drawend', async (event) => {
                        const newFeature = event.feature;
                        const coordinates = ol.proj.toLonLat(newFeature.getGeometry().getCoordinates(), 'EPSG:3857');
                        const geo = { type: "Point", coordinates: coordinates };
                        const props = { NOME: formValues.nome, tipo: formValues.tipo }; // Usa valores do formul√°rio SweetAlert

                        try {
                            const docRef = await db.collection("GeoData").doc("predios_publicos_PMG").collection("features").add({ geometry: JSON.stringify(geo), properties: props });
                            newFeature.setId(docRef.id);
                            newFeature.setProperties(props);
                            camadas.predios_publicos_PMG.source.addFeature(newFeature);
                            featureIndex[docRef.id] = { feature: newFeature, camada: "predios_publicos_PMG", props: { ...props } }; // Adiciona ao √≠ndice
                            drawSource.clear();
                            map.removeInteraction(drawInteraction);
                            map.removeLayer(drawLayer);
                            Swal.fire("‚úÖ Sucesso", "Novo ponto criado!", "success");
                        } catch (err) {
                            console.error("Erro ao criar ponto:", err);
                            Swal.fire("‚ùå Erro", "N√£o foi poss√≠vel criar o ponto.", "error");
                        }
                        document.body.style.cursor = "";
                    });
                }
            };

            mapFunctions.apagarPonto = async function() {
                // Esta fun√ß√£o tamb√©m pode ser removida se a exclus√£o n√£o for permitida.
                if (!selectedFeature || !selectedFeatureId) {
                    Swal.fire("Nada selecionado", "Nenhum ponto ou pol√≠gono para apagar.", "warning");
                    return;
                }

                const c = await Swal.fire({
                    title: "Tem certeza?",
                    text: "Essa a√ß√£o n√£o pode ser desfeita!",
                    icon: "warning",
                    showCancelButton: true,
                    confirmButtonText: "Sim, apagar",
                    cancelButtonText: "Cancelar"
                });

                if (c.isConfirmed) {
                    try {
                        const camadaKey = Object.keys(camadas).find(key => camadas[key].layer.getSource().getFeatureById(selectedFeatureId));
                        if (!camadaKey) {
                            Swal.fire("Erro", "Camada da fei√ß√£o selecionada n√£o encontrada.", "error");
                            return;
                        }
                        await db.collection("GeoData").doc(camadaKey).collection("features").doc(selectedFeatureId).delete();
                        camadas[camadaKey].source.removeFeature(selectedFeature);
                        delete featureIndex[selectedFeatureId]; // Remove do √≠ndice
                        selectedFeature = null;
                        selectedFeatureId = null;
                        Swal.fire("Apagado", "A fei√ß√£o foi removida.", "success");
                    } catch (err) {
                        console.error("Erro ao apagar ponto:", err);
                        Swal.fire("‚ùå Erro", "N√£o foi poss√≠vel apagar a fei√ß√£o.", "error");
                    }
                }
            };

            // NOVA FUN√á√ÉO: Gera o HTML para visualiza√ß√£o dos atributos
            mapFunctions.gerarPopupVisualizacao = function(props) {
                let html = `<table class="table-attributes">`;
                // Filtra propriedades internas do OL ao gerar o popup
                for (const key in props) {
                    if (key !== 'geometry' && key !== 'id' && key !== 'bbox' && key !== 'style') {
                        const value = props[key] !== undefined ? props[key] : 'N/A'; // Usa N/A para valores indefinidos
                        html += `
                            <tr>
                                <td><strong>${key}:</strong></td>
                                <td><span class="attribute-value">${value}</span></td>
                            </tr>
                        `;
                    }
                }
                html += `</table>`;
                return html;
            };

            // REMOVIDA: mapFunctions.salvarPopupEdicao = async function(camadaKey, featureId, updatedProps) { ... }

            /* ==================== Medi√ß√£o de Dist√¢ncia e √Årea ==================== */
            // Manteve as mensagens de ajuda no tooltip do OL, n√£o no SweetAlert  
            mapFunctions.addInteraction = function(type) {
                mapFunctions.clearMeasurements(); // Garante que qualquer medi√ß√£o e r√≥tulo anterior sejam removidos  

                measureSource = new ol.source.Vector();
                measureLayer = new ol.layer.Vector({
                    source: measureSource,
                    style: new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0.2)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#ffcc33',
                            width: 3
                        }),
                        image: new ol.style.Circle({
                            radius: 7,
                            fill: new ol.style.Fill({
                                color: '#ffcc33'
                            })
                        })
                    })
                });
                map.addLayer(measureLayer);

                measureDraw = new ol.interaction.Draw({
                    source: measureSource,
                    type: type,
                    style: new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0.2)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(0, 0, 0, 0.5)',
                            lineDash: [10, 10],
                            width: 2
                        }),
                        image: new ol.style.Circle({
                            radius: 5,
                            stroke: new ol.style.Stroke({
                                color: 'rgba(0, 0, 0, 0.7)'
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 255, 255, 0.2)'
                            })
                        })
                    })
                });
                map.addInteraction(measureDraw);

                map.on('pointermove', mapFunctions.pointerMoveHandler);

                // Cria ou reutiliza o helpTooltipElement e helpTooltip
                if (!helpTooltipElement) {
                    helpTooltipElement = document.createElement('div');
                    helpTooltipElement.className = 'ol-tooltip ol-tooltip-help';
                    document.body.appendChild(helpTooltipElement);
                    helpTooltip = new ol.Overlay({
                        element: helpTooltipElement,
                        offset: [15, 0],
                        positioning: 'center-left'
                    });
                    map.addOverlay(helpTooltip);
                }
                helpTooltipElement.style.display = 'block'; // Garante que esteja vis√≠vel

                measureDraw.on('drawstart', function(evt) {
                    var sketch = evt.feature;
                    var listener = sketch.getGeometry().on('change', function(evt) {
                        var geom = evt.target;
                        var output;
                        if (geom instanceof ol.geom.Polygon) {
                            output = mapFunctions.formatArea(geom);
                        } else if (geom instanceof ol.geom.LineString) {
                            output = mapFunctions.formatLength(geom);
                        }
                        // Cria ou reutiliza measureTooltipElement e measureTooltip
                        if (!measureTooltipElement) {
                            measureTooltipElement = document.createElement('div');
                            measureTooltipElement.className = 'ol-tooltip ol-tooltip-measure';
                            document.body.appendChild(measureTooltipElement);
                            measureTooltip = new ol.Overlay({
                                element: measureTooltipElement,
                                offset: [0, -15],
                                positioning: 'bottom-center'
                            });
                            map.addOverlay(measureTooltip);
                        }
                        measureTooltipElement.innerHTML = output;
                        measureTooltip.setPosition(geom.getLastCoordinate());
                    });
                });

                measureDraw.on('drawend', function(evt) {
                    if (measureTooltipElement) {
                        measureTooltipElement.className = 'ol-tooltip ol-tooltip-static';
                        measureTooltip.setOffset([0, -7]);
                    }
                    // Remove apenas o helpTooltip ap√≥s o t√©rmino do desenho
                    if (helpTooltipElement) {
                        helpTooltipElement.parentNode.removeChild(helpTooltipElement);
                        helpTooltipElement = null;
                    }
                    if (helpTooltip) { // Certifica-se de que o overlay √© removido
                        map.removeOverlay(helpTooltip);  
                        helpTooltip = null;
                    }
                    map.removeInteraction(measureDraw);
                    measureDraw = null; // Zera a refer√™ncia da intera√ß√£o
                    map.un('pointermove', mapFunctions.pointerMoveHandler); // Remove o listener de movimento do mouse
                });

                // Apenas um SweetAlert discreto para indicar a ativa√ß√£o do modo  
                Swal.mixin({ toast: true, position: 'top-end', showConfirmButton: false, timer: 3000, timerProgressBar: true }).fire({ icon: 'info', title: `Modo Medir ${type === 'LineString' ? 'Dist√¢ncia' : '√Årea'} ativado. Clique no mapa para desenhar.` });
            };

            mapFunctions.pointerMoveHandler = function(evt) {
                if (evt.dragging) {
                    return;
                }
                let helpMsg = 'Clique para come√ßar a desenhar';
                if (measureDraw && measureDraw.getSketch()) { // Verifica se sketch existe
                    const geometry = measureDraw.getSketch().getGeometry();
                    if (geometry instanceof ol.geom.Polygon) {
                        helpMsg = 'Clique para continuar desenhando o pol√≠gono, clique duas vezes para finalizar.';
                    } else if (geometry instanceof ol.geom.LineString) {
                        helpMsg = 'Clique para continuar desenhando a linha, clique duas vezes para finalizar.';
                    }
                }
                if (helpTooltipElement) {  
                    helpTooltipElement.innerHTML = helpMsg;
                    helpTooltip.setPosition(evt.coordinate);
                    helpTooltipElement.classList.remove('hidden');
                }
            };

            mapFunctions.formatLength = function(line) {
                var length = ol.sphere.getLength(line, { projection: 'EPSG:3857' });
                var output;
                if (length > 100) {
                    output = (Math.round(length / 1000 * 100) / 100) + ' ' + 'km';
                } else {
                    output = (Math.round(length * 100) / 100) + ' ' + 'm';
                }
                return output;
            };

            mapFunctions.formatArea = function(polygon) {
                var area = ol.sphere.getArea(polygon, { projection: 'EPSG:3857' });
                var output;
                if (area > 10000) {
                    output = (Math.round(area / 1000000 * 100) / 100) + ' ' + 'km<sup>2</sup>';
                } else {
                    output = (Math.round(area * 100) / 100) + ' ' + 'm<sup>2</sup>';
                }
                return output;
            };

            mapFunctions.toggleMeasureDistance = function() {
                mapFunctions.addInteraction('LineString');
            };

            mapFunctions.toggleMeasureArea = function() {
                mapFunctions.addInteraction('Polygon');
            };

            mapFunctions.clearMeasurements = function() {
                // Remove a intera√ß√£o de desenho se estiver ativa
                if (measureDraw) {
                    map.removeInteraction(measureDraw);
                    measureDraw = null;  
                }
                // Remove a camada de medi√ß√£o se estiver ativa e limpa a source
                if (measureLayer) {
                    map.removeLayer(measureLayer);
                    measureLayer = null;  
                    if (measureSource) {
                        measureSource.clear(); // Limpa todas as fei√ß√µes da source
                        measureSource = null;
                    }
                }
                // Remove os tooltips da medi√ß√£o
                if (measureTooltipElement) {
                    measureTooltipElement.parentNode.removeChild(measureTooltipElement);
                    measureTooltipElement = null;
                    if (measureTooltip) { // Garante que o overlay tamb√©m seja removido
                        map.removeOverlay(measureTooltip);  
                        measureTooltip = null;
                    }
                }
                // Remove o tooltip de ajuda
                if (helpTooltipElement) {
                    helpTooltipElement.parentNode.removeChild(helpTooltipElement);
                    helpTooltipElement = null;
                    if (helpTooltip) { // Garante que o overlay tamb√©m seja removido
                        map.removeOverlay(helpTooltip);  
                        helpTooltip = null;
                    }
                }
                map.un('pointermove', mapFunctions.pointerMoveHandler); // Remove o listener do mouse

                Swal.mixin({
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 2000,
                    timerProgressBar: true,
                }).fire({
                    icon: 'info',
                    title: 'Medi√ß√µes limpas.'
                });
            };


            /* ==================== Exporta√ß√£o de Camadas (KML) ==================== */
            mapFunctions.exportToKML = async function(layerKey) {
                const cfg = camadas[layerKey];
                if (!cfg || !cfg.source) {
                    Swal.fire('Erro', 'Camada n√£o encontrada ou sem dados para exportar.', 'error', {
                        position: 'top-end', backdrop: false
                    });
                    return;
                }

                Swal.fire({
                    title: `Exportando ${cfg.nome} para KML...`,
                    html: 'Isso deve ser r√°pido!',
                    allowOutsideClick: false,
                    didOpen: () => {
                        Swal.showLoading();
                    },
                    position: 'top-end',
                    backdrop: false
                });

                try {
                    const features = cfg.source.getFeatures();
                    if (features.length === 0) {
                        Swal.fire('Aviso', 'A camada selecionada n√£o cont√©m fei√ß√µes para exportar.', 'warning', {
                            position: 'top-end', backdrop: false
                        });
                        return;
                    }

                    const kmlFormat = new ol.format.KML({
                        extractStyles: false,  
                        showPointNames: true,  
                        defaultStyle: [  
                            new ol.style.Style({
                                fill: new ol.style.Fill({
                                    color: 'rgba(0, 0, 255, 0.5)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#0000ff',
                                    width: 2
                                })
                            })
                        ]
                    });

                    const kmlString = kmlFormat.writeFeatures(features, {
                        featureProjection: 'EPSG:3857',  
                        dataProjection: 'EPSG:4326'    
                    });

                    const blob = new Blob([kmlString], { type: 'application/vnd.google-earth.kml+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const dateString = new Date().toISOString().slice(0,10).replace(/-/g, '');
                    a.download = `${cfg.nome.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}_${dateString}.kml`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    Swal.fire('Sucesso!', `Camada "${cfg.nome}" exportada para KML com sucesso!`, 'success', {
                        position: 'top-end', backdrop: false
                    });

                } catch (error) {
                    console.error('Erro ao exportar KML:', error);
                    Swal.fire('Erro', `Falha ao exportar para KML: ${error.message}. Verifique o console para mais detalhes.`, 'error', {
                        position: 'top-end', backdrop: false
                    });
                }
            };

            mapFunctions.mostrarOpcoesExportacao = async function() {
                const opcoesCamadas = Object.keys(camadas)
                    .filter(key => camadas[key].source && camadas[key].source.getFeatures().length > 0)  
                    .map(key => ({ value: key, text: camadas[key].nome }));  

                if (opcoesCamadas.length === 0) {
                    Swal.fire('Aviso', 'Nenhuma camada com dados para exportar no momento.', 'warning', {
                        position: 'top-end', backdrop: false
                    });
                    return;
                }

                const inputOptions = {};
                opcoesCamadas.forEach(opt => {
                    inputOptions[opt.value] = opt.text;
                });

                const { value: selectedLayerKey } = await Swal.fire({
                    title: 'Escolha a camada para exportar',
                    input: 'select',
                    inputOptions: inputOptions,
                    inputPlaceholder: 'Selecione uma camada',
                    showCancelButton: true,
                    confirmButtonText: 'Exportar KML',  
                    position: 'top-end',  
                    width: '400px',      
                    backdrop: false,      
                    inputValidator: (value) => {
                        if (!value) {
                            return 'Voc√™ precisa selecionar uma camada!';
                        }
                    }
                });

                if (selectedLayerKey) {
                    mapFunctions.exportToKML(selectedLayerKey);  
                }
            };

            /* ==================== MODO DE IMPRESS√ÉO (TELA A4) ==================== */
            let initialBodyStyle = ''; // String para guardar todos os estilos inline
            let initialMapStyle = '';  // String para guardar todos os estilos inline
            let printModeKeyListener = null;  

            mapFunctions.activatePrintMode = function() {
                // Esconder todos os controles da UI principal
                mainFormContainer.classList.add('hidden-for-print');
                customLayerControl.classList.add('hidden-for-print');
                searchContainer.classList.add('hidden-for-print'); // Oculta o container de busca
                olControlsToHide.forEach(control => {
                    if (control) control.classList.add('hidden-for-print');
                });
                
                // Salvar todos os estilos inline atuais do body e map
                initialBodyStyle = document.body.style.cssText;
                initialMapStyle = map.getTargetElement().style.cssText;

                // Aplicar classes de modo de impress√£o
                document.body.classList.add('print-mode-active');
                map.getTargetElement().classList.add('print-mode-active');
                
                // For√ßar o mapa a renderizar na nova dimens√£o imediatamente
                map.updateSize();

                // Mostrar controles do modo de impress√£o, seta do norte e escala gr√°fica do OL
                printModeControls.style.display = 'block';
                northArrowPrint.style.display = 'block';
                scaleLineControl.getElement().classList.add('visible-for-print'); // Torna o ScaleLine vis√≠vel e posiciona

                // Adicionar listener para a tecla ESC no modo de impress√£o
                printModeKeyListener = (event) => {
                    if (event.key === 'Escape') {
                        mapFunctions.deactivatePrintMode();
                    }
                };
                document.addEventListener('keydown', printModeKeyListener);

                Swal.mixin({
                    toast: true,
                    position: 'top-start',
                    showConfirmButton: false,
                    timer: 5000,
                    timerProgressBar: true,
                    didOpen: (toast) => {
                        toast.addEventListener('mouseenter', Swal.stopTimer)
                        toast.addEventListener('mouseleave', Swal.resumeTimer)
                    }
                }).fire({
                    icon: 'info',
                    title: 'Modo Impress√£o Ativado! Use o mouse para ajustar o mapa. Pressione ESC ou "Cancelar" para sair.'
                });
            };

            mapFunctions.deactivatePrintMode = function() {
                // Remover classes de modo de impress√£o
                document.body.classList.remove('print-mode-active');
                map.getTargetElement().classList.remove('print-mode-active');
                
                // Restaurar estilos inline originais
                document.body.style.cssText = initialBodyStyle;
                map.getTargetElement().style.cssText = initialMapStyle;

                // Reexibir todos os controles da UI principal
                mainFormContainer.classList.remove('hidden-for-print');
                customLayerControl.classList.remove('hidden-for-print');
                searchContainer.classList.remove('hidden-for-print'); // Mostra o container de busca
                olControlsToHide.forEach(control => {
                    if (control) control.classList.remove('hidden-for-print');
                });

                // Esconder controles do modo de impress√£o, seta do norte e escala gr√°fica do OL
                printModeControls.style.display = 'none';
                northArrowPrint.style.display = 'none';
                scaleLineControl.getElement().classList.remove('visible-for-print'); // Esconde o ScaleLine  

                // Remover listener da tecla ESC
                if (printModeKeyListener) {
                    document.removeEventListener('keydown', printModeKeyListener);
                    printModeKeyListener = null;
                }

                // For√ßar o mapa a renderizar no tamanho original da tela
                map.updateSize();

                Swal.mixin({
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 2000,
                    timerProgressBar: true,
                }).fire({
                    icon: 'success',
                    title: 'Modo Impress√£o Desativado.'
                });
            };

            mapFunctions.triggerPrint = function() {
                // Esconder controles do modo de impress√£o para a sa√≠da final
                printModeControls.style.display = 'none';

                // Disparar a impress√£o do navegador
                // Usar um pequeno timeout para garantir que todos os estilos estejam aplicados
                setTimeout(() => {
                    window.print();
                    // Chamar deactivatePrintMode ap√≥s a impress√£o ser conclu√≠da/cancelada.
                    // O evento 'afterprint' √© mais preciso, mas como a manipula√ß√£o de DOM √© antes/depois do print()
                    // o setTimeout ap√≥s o print ainda √© uma solu√ß√£o comum.
                    setTimeout(() => {
                        mapFunctions.deactivatePrintMode();
                    }, 500); // Pequeno atraso para o navegador processar o evento de impress√£o
                }, 100);  
            };


            /* ================= Mecanismo de Busca ================= */
            const camadaSelect = document.getElementById("camadaSelect");
            const campoSelect = document.getElementById("campoSelect");
            const inputBusca = document.getElementById("valorBusca");
            const sugestoes = document.getElementById("sugestoes");
            const cacheCampos = {};
            let currentSearchHighlightFeature = null; // Armazena a fei√ß√£o atualmente destacada
            let currentSearchHighlightLayer = null; // Armazena a camada da fei√ß√£o destacada

            // Inicializa o select de camadas com as camadas dispon√≠veis
            for (const key in camadas) {
                camadaSelect.innerHTML += `<option value="${key}">${camadas[key].nome}</option>`;
            }

            // Fun√ß√£o para preencher o select de campos com base na camada escolhida
            async function preencherCampoSelect(campos) {
                campoSelect.innerHTML = "";
                if (campos.length === 0) {
                    campoSelect.innerHTML = "<option value=''>Nenhum campo dispon√≠vel</option>";
                    return;
                }
                campos.forEach(k => {
                    campoSelect.innerHTML += `<option value="${k}">${k}</option>`;
                });
            }

            // Listener de evento para mudan√ßa na sele√ß√£o de camada
            camadaSelect.addEventListener("change", async () => {
                const camadaKey = camadaSelect.value;
                if (!camadaKey) {
                    campoSelect.innerHTML = "<option value=''>Selecione uma camada</option>";
                    sugestoes.style.display = "none";
                    return;
                }

                campoSelect.innerHTML = "<option>Carregando...</option>";
                if (cacheCampos[camadaKey]) {
                    preencherCampoSelect(cacheCampos[camadaKey]);
                    return;
                }

                try {
                    // Busca um √∫nico documento para obter suas propriedades (campos)
                    const snapshot = await db.collection("GeoData").doc(camadaKey).collection("features").limit(1).get();
                    campoSelect.innerHTML = "";
                    if (!snapshot.empty) {
                        const doc = snapshot.docs[0].data();
                        const campos = Object.keys(doc.properties || {});
                        cacheCampos[camadaKey] = campos;
                        preencherCampoSelect(campos);
                    } else {
                        campoSelect.innerHTML = "<option value=''>Nenhum campo dispon√≠vel (camada vazia)</option>";
                    }
                } catch (error) {
                    console.error("Erro ao buscar campos:", error);
                    campoSelect.innerHTML = "<option value=''>Erro ao carregar campos</option>";
                }
                sugestoes.style.display = "none"; // Oculta sugest√µes ao mudar de camada
            });

            // Dispara o preenchimento inicial do campo para a primeira camada
            if (camadaSelect.value) {
                camadaSelect.dispatchEvent(new Event('change'));
            }

            // Listener de evento para input de busca (sugest√µes)
            inputBusca.addEventListener("input", async () => {
                const camadaKey = camadaSelect.value;
                const campo = campoSelect.value;
                const valor = inputBusca.value.trim().toLowerCase();

                if (!valor || !campo || !camadaKey) {
                    sugestoes.innerHTML = "";
                    sugestoes.style.display = "none";
                    return;
                }

                sugestoes.innerHTML = "";
                const ref = db.collection("GeoData").doc(camadaKey).collection("features");
                
                // Busca todas as fei√ß√µes da camada selecionada para gerar sugest√µes.
                // Para grandes volumes de dados, considere otimiza√ß√µes no backend.
                const snapshot = await ref.get();
                const valoresUnicos = new Set();

                snapshot.forEach(doc => {
                    const properties = doc.data().properties;
                    const dataValue = properties ? properties[campo] : undefined;
                    if (dataValue && String(dataValue).toLowerCase().includes(valor)) {
                        valoresUnicos.add(dataValue);
                    }
                });

                if (valoresUnicos.size > 0) {
                    // Ordena as sugest√µes alfabeticamente
                    Array.from(valoresUnicos).sort().forEach(v => {
                        const div = document.createElement("div");
                        div.textContent = v;
                        div.className = "sugestao-item";
                        div.onclick = () => {
                            inputBusca.value = v;
                            sugestoes.style.display = "none";
                            mapFunctions.buscarFeicao(); // Dispara a busca ao clicar na sugest√£o
                        };
                        sugestoes.appendChild(div);
                    });
                    sugestoes.style.display = "block";
                } else {
                    sugestoes.style.display = "none";
                }
            });

            // Oculta as sugest√µes ao clicar fora do input ou da lista de sugest√µes
            document.addEventListener("click", (e) => {
                if (!sugestoes.contains(e.target) && e.target !== inputBusca) {
                    sugestoes.style.display = "none";
                }
            });

            // Camada para destacar as fei√ß√µes pesquisadas
            const highlightSource = new ol.source.Vector();
            const highlightLayer = new ol.layer.Vector({
                source: highlightSource,
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#00FF00', // Verde lim√£o vibrante para a borda
                        width: 8        // Borda mais espessa para maior visibilidade
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(0, 255, 0, 0.5)' // Verde lim√£o semitransparente para o preenchimento
                    }),
                    image: new ol.style.Circle({
                        radius: 15,        // Raio maior para pontos
                        fill: new ol.style.Fill({ color: '#00FF00' }), // Preenchimento do ponto verde lim√£o vibrante
                        stroke: new ol.style.Stroke({ color: '#000000', width: 4 }) // Borda preta forte para o ponto
                    })
                }),
                zIndex: Infinity // Garante que a camada de destaque esteja sempre no topo
            });
            map.addLayer(highlightLayer);

            mapFunctions.clearSearchHighlight = function() {
                highlightSource.clear(); // Limpa todas as fei√ß√µes da camada de destaque
                currentSearchHighlightFeature = null;
                currentSearchHighlightLayer = null;
                Swal.mixin({
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 2000,
                    timerProgressBar: true,
                }).fire({
                    icon: 'info',
                    title: 'Destaque de busca limpo.'
                });
            };

            mapFunctions.buscarFeicao = async function() {
                mapFunctions.clearSearchHighlight(); // Limpa o destaque anterior ANTES de buscar. ESSENCIAL!
                sugestoes.style.display = "none"; // Oculta as sugest√µes

                const camadaKey = camadaSelect.value;
                const campo = campoSelect.value;
                const valor = inputBusca.value.trim();

                if (!camadaKey || !campo || !valor) {
                    Swal.fire('Aviso', 'Por favor, selecione uma camada, um campo e digite um valor para buscar.', 'warning', {
                        position: 'top-end', backdrop: false
                    });
                    return;
                }

                Swal.fire({
                    title: 'Buscando...',
                    html: 'Procurando a fei√ß√£o no mapa.',
                    allowOutsideClick: false,
                    didOpen: () => {
                        Swal.showLoading();
                    },
                    position: 'top-end',
                    backdrop: false
                });

                try {
                    const querySnapshot = await db.collection("GeoData").doc(camadaKey).collection("features")
                        .where(`properties.${campo}`, '==', valor) // Busca por correspond√™ncia exata
                        .get();

                    if (!querySnapshot.empty) {
                        const firstDoc = querySnapshot.docs[0];
                        const featureId = firstDoc.id;
                        const foundFeatureData = featureIndex[featureId];

                        if (foundFeatureData && foundFeatureData.feature) {
                            const featureToHighlight = foundFeatureData.feature.clone();  
                            featureToHighlight.setProperties(foundFeatureData.feature.getProperties()); 

                            featureToHighlight.setStyle(new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#00FF00', // Verde lim√£o vibrante para a borda
                                    width: 8
                                }),
                                fill: new ol.style.Fill({
                                    color: 'rgba(0, 255, 0, 0.5)' // Semi-transparente para o preenchimento
                                }),
                                image: new ol.style.Circle({
                                    radius: 15,
                                    fill: new ol.style.Fill({ color: '#00FF00' }),
                                    stroke: new ol.style.Stroke({ color: '#000000', width: 4 })
                                })
                            }));
                            
                            highlightSource.addFeature(featureToHighlight);
                            
                            currentSearchHighlightFeature = featureToHighlight;  
                            currentSearchHighlightLayer = camadaKey; 

                            const geometry = featureToHighlight.getGeometry();
                            if (geometry) {
                                const extent = geometry.getExtent();
                                map.getView().fit(extent, {
                                    padding: [50, 50, 50, 50], // Adiciona um preenchimento em volta da fei√ß√£o
                                    duration: 1000 // Anima√ß√£o suave
                                });
                            }
                            Swal.close();
                            Swal.mixin({
                                toast: true,
                                position: 'top-end',
                                showConfirmButton: false,
                                timer: 3000,
                                timerProgressBar: true,
                            }).fire({
                                icon: 'success',
                                title: `Fei√ß√£o encontrada na camada "${camadas[camadaKey].nome}"!`
                            });
                        } else {
                            Swal.close();
                            Swal.fire('N√£o Encontrado', 'Fei√ß√£o n√£o encontrada no cache local ou dados inconsistentes.', 'info', {
                                position: 'top-end', backdrop: false
                            });
                        }
                    } else {
                        Swal.close();
                        Swal.fire('N√£o Encontrado', 'Nenhuma fei√ß√£o encontrada com o valor especificado.', 'info', {
                            position: 'top-end', backdrop: false
                        });
                    }
                } catch (error) {
                    console.error("Erro ao buscar fei√ß√£o:", error);
                    Swal.close();
                    Swal.fire('Erro na Busca', `Ocorreu um erro ao buscar a fei√ß√£o: ${error.message}`, 'error', {
                        position: 'top-end', backdrop: false
                    });
                }
            };


            /* ================= Utilidades ================= */
            function getRandomColor() { return '#' + Math.floor(Math.random() * 16777215).toString(16); }

        } // Fim da fun√ß√£o initializeMapAndLayers  
    </script>
</body>
</html>
